functions {
	matrix admixed_covariance(int N, int K, vector[] w, vector nugget, vector mu, vector sampleSize) {
		matrix[N,N] Sigma;
		matrix[N,N] Nug_mat;
		Nug_mat <- diag_matrix(nugget);
		Sigma <- rep_matrix(0,N,N);
		for (i in 1:(N-1)){
			for (j in (i+1):N){
				for(k in 1:K){
					Sigma[i, j] <- Sigma[i, j]  +  w[i,k] * w[j,k] * mu[k];
				}
				Sigma[j, i] <- Sigma[i, j];			
			}
		}
		for(i in 1:N){
			for(k in 1:K){
				Sigma[i, i] <- Sigma[i, i] + w[i,k]^2 * mu[k];
			}
			Sigma[i,i] <- Sigma[i,i] * (1 - Sigma[i,i]) * (1/sampleSize[i]);
		}
		Sigma <- Sigma + Nug_mat;
		return Sigma;
	}
}
data {
	int<lower=1> K;		  				// number of clusters
	int<lower=2> N; 	  				// number of samples
	int<lower=N+1> L;	    			// number of loci
	cov_matrix[N-1] obsSigma; 			// observed projected covariance
	matrix[N, N] geoDist; 				// matrix of pairwise geographic distance 
	matrix[N, N-1] projMat;				// projection matrix
	vector[N] sampleSize;				// number of genotyped chromosomes in each sample
}
parameters {
	real<lower=0> mu_free[K-1];				// shared drift effect in cluster k
  	vector<lower=0>[N] nugget; 				// sample-specific variance (allele sampling error + sample-specific drift)
	simplex[K]    w[N];    					// every sample (N in total) has a K simplex (i.e. K clusters)
	vector<lower=0>[K] DirichAlpha; 		// dirichlet prior parameters on admixture proportions
	real<lower=0> dirichHP[K];				// hyperpriors on dirichlet parameters
}
transformed parameters {
	matrix[N-1, N-1]  projSigma;			// the mean-centered and projected covariance matrix (dim = N-1 x N-1)
	cov_matrix[N] Sigma;					// this specifies the parametric, admixed covariance matrix
	vector[K] mu;
	mu[1] <- 0;
	for(i in 2:K){
		mu[i] <- mu_free[i-1];
	}
	Sigma <- admixed_covariance(N, K, w, nugget, mu, sampleSize);
	projSigma <- quad_form(Sigma, projMat);
}
model {
	nugget ~ uniform(0,100);									// prior on nugget
	mu_free ~ normal(0,0.01);									// prior on cluster shared drift
	for(i in 1:N) w[i] ~ dirichlet(DirichAlpha);				// prior on admixture proportions
	for(i in 1:K) DirichAlpha[i] ~ exponential(dirichHP[i]);	// hyperprior on dirichlet conc. params.
	dirichHP ~ normal(100,10);									// prior on dirichlet hyperprior
	obsSigma ~ wishart(L,projSigma);							// likelihood function	
}
